with Ada.Strings.UTF_Encoding.Wide_Wide_Strings;

with Umwi.Combining;

package body Umwi is

   ----------------
   -- Properties --
   ----------------

   function Properties (Symbol : WWChar) return Emoji_Property_Array
                        is separate;
   --  Generated by nested crate "generator"

   function Width (Symbol : WWChar) return East_Asian_Width
                   is separate;
   --  Generated by nested crate "generator"

   -----------
   -- Width --
   -----------

   function Width (Symbol  : WWChar;
                   Context : Contexts := (if Narrow_Context
                                          then Narrow
                                          else Wide))
                   return Widths
   is (case East_Asian_Width'(Width (Symbol)) is
          when A      =>
            (case Context is
                when Narrow => 1,
                when Wide   => 2),
          when F | W  => 2,
          when others => 1);

   -----------------
   -- Extra_Width --
   -----------------

   function Extra_Width (Text           : WWString;
                         Context        : Contexts := (if Narrow_Context
                                                       then Narrow
                                                       else Wide);
                         Honor_Selector : Boolean := Honor_Selectors)
                         return Natural
   is
      Result : Natural;

      type Optional_Symbol (Empty : Boolean := True) is record
         case Empty is
            when True  => null;
            when False => Symbol : WWChar;
         end case;
      end record;

      Base   : Optional_Symbol := (Empty => True);
      --  Last thing we have seen that has a width

      ----------------
      -- New_Symbol --
      ----------------

      function New_Symbol (Char : WWChar) return Optional_Symbol
      is (Empty  => False,
          Symbol => Char);

      -------------
      -- Compute --
      -------------

      procedure Compute (Next : Optional_Symbol) is
         --  Next.Empty implies End of Text
      begin
         --  We see a new base emoji or end of text, we most compute the
         --  previous emoji sequence.
         if Next.Empty
           or else Properties (Next.Symbol) (Emoji)
         then
            --  VOY POR AQUÍ, REPASAR QUE SOLO CONSIDERAMOS SEQUENCIAS DE EMOJIS LUEGO EL ÚLTIMO ENCODING ERROR AHORA ESTÁ MAL

            --  We are seeing a printable, so we must compute previous seq
            if not Base.Empty then
               Result := Result + Width (Base.Symbol, Context) - 1;
            end if;

            --  Reset base
            if not Next.Empty then
               Base := (Empty => False, Symbol => Next.Symbol);
            end if;

         elsif Next.Symbol in Selectors then
            --  Adjust accordingly for selectors
            if Honor_Selector then
               if Base.Empty then
                  raise Encoding_Error with
                    "Seeing a presentation selector without base emoji";
               end if;

               --  We use a known narrow/wide emoji as base to supplant the
               --  actual one:
               case Selectors'(Next.Symbol) is
                  when Text_Selector =>
                     Base := New_Symbol ('☄'); -- Comet is Narrow
                  when Presentation_Selector =>
                     Base := New_Symbol ('✨'); -- Sparkles is Wide
               end case;
            end if;

         elsif not Properties (Next.Symbol) (Emoji)
           and then (for some Prop of Properties (Next.Symbol) => Prop)
         then
            --  We are seeing a modifier over the base emoji
            if Base.Empty then
               raise Encoding_Error with
                 "Seeing emoji modifier without emoji base";
            end if;

         else
            --  Not sure what we are seeing but it shouldn't happen
            raise Encoding_Error with
              "Seeing unexpected Unicode sequence";
         end if;
      end Compute;

   begin
      for Char of Text loop
         Compute ((Empty  => False,
                   Symbol => Char));
      end loop;

      Compute ((Empty => True));

      return Result;
   end Extra_Width;

   -----------------
   -- Extra_Width --
   -----------------

   function Extra_Width (Text           : UTF8_String;
                         Context        : Contexts := (if Narrow_Context
                                                       then Narrow
                                                       else Wide);
                         Honor_Selector : Boolean := Honor_Selectors)
                         return Natural
   is
      use Ada.Strings.UTF_Encoding.Wide_Wide_Strings;
   begin
      return Extra_Width (Text           => Decode (String (Text)),
                          Context        => Context,
                          Honor_Selector => Honor_Selector);
   end Extra_Width;

end Umwi;
